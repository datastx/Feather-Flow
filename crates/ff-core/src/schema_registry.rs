//! Schema registry for column metadata lookup
//!
//! Provides a unified view of column names, types, and descriptions across
//! all project nodes (models, sources, seeds). Used by lineage to compute
//! description propagation status.

use crate::project::Project;
use std::collections::HashMap;

/// Metadata for a single column in a node.
#[derive(Debug, Clone)]
pub struct ColumnInfo {
    /// Column name
    pub name: String,
    /// SQL data type
    pub data_type: String,
    /// Optional human-readable description
    pub description: Option<String>,
    /// Whether the description was generated by an AI agent.
    /// `Some(true)` = AI-generated, `Some(false)` = human-written, `None` = unknown provenance.
    pub description_ai_generated: Option<bool>,
}

/// Registry of column metadata indexed by node name then column name.
#[derive(Debug, Default)]
pub struct SchemaRegistry {
    /// node_name -> { column_name_lowercase -> ColumnInfo }
    nodes: HashMap<String, HashMap<String, ColumnInfo>>,
}

/// Shared column-info fields present on both `SchemaColumnDef` and `SourceColumn`.
trait ColumnInfoSource {
    fn col_name(&self) -> &str;
    fn col_data_type(&self) -> &str;
    fn col_description(&self) -> Option<&str>;
    fn col_description_ai_generated(&self) -> Option<bool>;
}

impl ColumnInfoSource for crate::model::SchemaColumnDef {
    fn col_name(&self) -> &str {
        &self.name
    }
    fn col_data_type(&self) -> &str {
        &self.data_type
    }
    fn col_description(&self) -> Option<&str> {
        self.description.as_deref()
    }
    fn col_description_ai_generated(&self) -> Option<bool> {
        self.description_ai_generated
    }
}

impl ColumnInfoSource for crate::source::SourceColumn {
    fn col_name(&self) -> &str {
        &self.name
    }
    fn col_data_type(&self) -> &str {
        &self.data_type
    }
    fn col_description(&self) -> Option<&str> {
        self.description.as_deref()
    }
    fn col_description_ai_generated(&self) -> Option<bool> {
        self.description_ai_generated
    }
}

fn columns_to_map<'a, C: ColumnInfoSource + 'a>(
    cols: impl Iterator<Item = &'a C>,
) -> HashMap<String, ColumnInfo> {
    cols.map(|col| {
        (
            col.col_name().to_lowercase(),
            ColumnInfo {
                name: col.col_name().to_string(),
                data_type: col.col_data_type().to_string(),
                description: col.col_description().map(String::from),
                description_ai_generated: col.col_description_ai_generated(),
            },
        )
    })
    .collect()
}

impl SchemaRegistry {
    /// Build a registry from a loaded project.
    ///
    /// Collects columns from:
    /// - Model YAML schemas (`project.models`)
    /// - Source table definitions (`project.sources`)
    pub fn from_project(project: &Project) -> Self {
        let mut registry = Self::default();

        for (name, model) in &project.models {
            if let Some(schema) = &model.schema {
                let cols = columns_to_map(schema.columns.iter());
                if !cols.is_empty() {
                    registry.nodes.insert(name.to_string(), cols);
                }
            }
        }

        for source_file in &project.sources {
            for table in &source_file.tables {
                let cols = columns_to_map(table.columns.iter());
                if !cols.is_empty() {
                    registry.nodes.insert(table.name.clone(), cols);
                }
            }
        }

        registry
    }

    /// Look up a single column in a node.
    pub fn get_column(&self, node: &str, column: &str) -> Option<&ColumnInfo> {
        self.nodes
            .get(node)
            .and_then(|cols| cols.get(&column.to_lowercase()))
    }

    /// Get all columns for a node.
    pub fn get_columns(&self, node: &str) -> Option<&HashMap<String, ColumnInfo>> {
        self.nodes.get(node)
    }
}
