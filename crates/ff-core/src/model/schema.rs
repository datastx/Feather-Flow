//! Schema metadata types for model YAML files

use super::testing::{parse_test_definition, SchemaTest, TestConfig, TestDefinition};
use crate::error::CoreError;
use crate::model_name::ModelName;
use serde::{Deserialize, Serialize};

/// The kind of resource described by a model directory.
///
/// Accepts both modern (`sql`) and legacy (`model`) names.
/// Comparison via [`PartialEq`] treats `Sql` and `Model` as equivalent.
#[derive(Debug, Clone, Copy, Eq, Serialize, Deserialize, Default)]
#[serde(rename_all = "lowercase")]
pub enum ModelKind {
    /// A SQL model (default) — directory contains a `.sql` file
    #[default]
    Model,
    /// Modern alias for [`ModelKind::Model`]
    Sql,
    /// A CSV seed — directory contains a `.csv` file
    Seed,
    /// A Python model — directory contains a `.py` file, executed via `uv run`
    Python,
}

impl PartialEq for ModelKind {
    fn eq(&self, other: &Self) -> bool {
        std::mem::discriminant(&self.normalize()) == std::mem::discriminant(&other.normalize())
    }
}

impl ModelKind {
    /// Collapse legacy `Model` to the canonical `Sql` form.
    fn normalize(self) -> ModelKind {
        match self {
            ModelKind::Model | ModelKind::Sql => ModelKind::Sql,
            other => other,
        }
    }

    /// Returns `true` if this is a SQL model kind (either `model` or `sql`).
    pub fn is_sql(&self) -> bool {
        matches!(self, ModelKind::Model | ModelKind::Sql)
    }
}

impl std::fmt::Display for ModelKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ModelKind::Model | ModelKind::Sql => write!(f, "sql"),
            ModelKind::Seed => write!(f, "seed"),
            ModelKind::Python => write!(f, "python"),
        }
    }
}

/// Python-specific configuration for `kind: python` models
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct PythonConfig {
    /// Minimum Python version requirement (e.g., ">=3.11")
    #[serde(default, rename = "requires-python")]
    pub requires_python: Option<String>,

    /// Python package dependencies (e.g., ["pandas>=2.0", "scikit-learn>=1.3"])
    #[serde(default)]
    pub dependencies: Vec<String>,
}

/// Schema metadata for a single model (from 1:1 .yml file)
///
/// This follows the 1:1 naming convention where each model's schema file
/// has the same name as its SQL file (e.g., stg_orders.sql + stg_orders.yml)
///
/// Model configuration (materialization, schema, hooks, etc.) is specified
/// exclusively in this YAML file.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct ModelSchema {
    /// Schema format version
    pub version: u32,

    /// Resource kind: `model` (default) or `seed`
    #[serde(default)]
    pub kind: ModelKind,

    /// Model name (optional, must match SQL file if provided)
    #[serde(default)]
    pub name: Option<String>,

    /// Model description
    #[serde(default)]
    pub description: Option<String>,

    /// Whether the description was generated by an AI agent.
    /// `Some(true)` = AI-generated, `Some(false)` = human-written, `None` = unknown provenance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description_ai_generated: Option<bool>,

    /// Model owner (team or person) - deprecated, use meta.owner
    #[serde(default)]
    pub owner: Option<String>,

    /// Arbitrary metadata (owner, team, slack_channel, etc.)
    #[serde(default)]
    pub meta: std::collections::HashMap<String, serde_yaml::Value>,

    /// Tags for categorization
    #[serde(default)]
    pub tags: Vec<String>,

    /// Column definitions
    #[serde(default)]
    pub columns: Vec<SchemaColumnDef>,

    /// Whether this model is deprecated
    #[serde(default)]
    pub deprecated: bool,

    /// Deprecation message to show users (e.g., "Use fct_orders_v2 instead")
    #[serde(default)]
    pub deprecation_message: Option<String>,

    /// Materialization type (view, table, incremental, ephemeral)
    #[serde(default)]
    pub materialized: Option<String>,

    /// Explicit dependency list for Python models (kind: python only).
    /// Since Python scripts cannot be parsed for SQL table references,
    /// dependencies must be declared here.
    #[serde(default)]
    pub depends_on: Vec<String>,

    /// Python-specific configuration (kind: python only)
    #[serde(default)]
    pub python: Option<PythonConfig>,

    /// Override target schema for seed/model loading
    #[serde(default)]
    pub schema: Option<String>,

    /// Unique key column(s) for incremental merge (comma-separated string or list)
    #[serde(default)]
    pub unique_key: Option<StringOrVec>,

    /// Incremental strategy (append, merge, delete+insert)
    #[serde(default)]
    pub incremental_strategy: Option<String>,

    /// Schema change handling for incremental models (ignore, fail, append_new_columns)
    #[serde(default)]
    pub on_schema_change: Option<String>,

    /// SQL statements to execute before the model runs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pre_hook: Option<StringOrVec>,

    /// SQL statements to execute after the model runs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub post_hook: Option<StringOrVec>,

    /// Whether this model uses Write-Audit-Publish pattern
    #[serde(default)]
    pub wap: Option<bool>,

    /// Force column quoting for seed CSV (kind: seed only)
    #[serde(default)]
    pub quote_columns: bool,

    /// Override inferred types for specific columns (kind: seed only).
    /// Key: column name, Value: SQL type (e.g., "VARCHAR", "INTEGER")
    #[serde(default)]
    pub column_types: std::collections::HashMap<String, String>,

    /// CSV delimiter for seed loading (kind: seed only, default: ',')
    #[serde(default = "default_delimiter")]
    pub delimiter: char,

    /// Enable/disable this seed (kind: seed only, default: true)
    #[serde(default = "default_enabled")]
    pub enabled: bool,
}

fn default_delimiter() -> char {
    ','
}

fn default_enabled() -> bool {
    true
}

/// A value that can be either a single string or a list of strings.
///
/// In YAML, users can write either:
/// ```yaml
/// unique_key: id
/// ```
/// or:
/// ```yaml
/// unique_key:
///   - id
///   - date
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StringOrVec {
    Single(String),
    Multiple(Vec<String>),
}

impl StringOrVec {
    /// Convert to a Vec<String>, splitting single strings on commas.
    /// Use this for column lists (e.g. unique_key).
    pub fn to_vec(&self) -> Vec<String> {
        match self {
            StringOrVec::Single(s) => s
                .split(',')
                .map(|part| part.trim().to_string())
                .filter(|s| !s.is_empty())
                .collect(),
            StringOrVec::Multiple(v) => v.clone(),
        }
    }

    /// Convert to a Vec<String> without splitting on commas.
    /// Use this for hooks and other values where a single string
    /// should remain as one element.
    pub fn to_vec_raw(&self) -> Vec<String> {
        match self {
            StringOrVec::Single(s) => vec![s.clone()],
            StringOrVec::Multiple(v) => v.clone(),
        }
    }

    /// Convert to a single comma-separated string.
    pub fn to_comma_string(&self) -> String {
        match self {
            StringOrVec::Single(s) => s.clone(),
            StringOrVec::Multiple(v) => v.join(","),
        }
    }
}

impl Default for ModelSchema {
    fn default() -> Self {
        Self {
            version: 1,
            kind: ModelKind::default(),
            name: None,
            description: None,
            description_ai_generated: None,
            owner: None,
            meta: std::collections::HashMap::new(),
            tags: Vec::new(),
            columns: Vec::new(),
            deprecated: false,
            deprecation_message: None,
            materialized: None,
            depends_on: Vec::new(),
            python: None,
            schema: None,
            unique_key: None,
            incremental_strategy: None,
            on_schema_change: None,
            pre_hook: None,
            post_hook: None,
            wap: None,
            quote_columns: false,
            column_types: std::collections::HashMap::new(),
            delimiter: default_delimiter(),
            enabled: default_enabled(),
        }
    }
}

impl ModelSchema {
    /// Load schema from a file path
    pub fn load(path: &std::path::Path) -> Result<Self, CoreError> {
        let content = std::fs::read_to_string(path).map_err(|e| CoreError::IoWithPath {
            path: path.display().to_string(),
            source: e,
        })?;
        Self::load_from_str(&content, path)
    }

    /// Load schema from already-read YAML content, using `path` only for error messages.
    pub fn load_from_str(content: &str, path: &std::path::Path) -> Result<Self, CoreError> {
        let schema: ModelSchema = serde_yaml::from_str(content).map_err(|e| {
            use serde::de::Error as _;
            CoreError::YamlParse(serde_yaml::Error::custom(format!(
                "{}: {}",
                path.display(),
                e
            )))
        })?;
        if schema.version != 1 {
            return Err(CoreError::UnsupportedSchemaVersion {
                version: schema.version,
            });
        }
        Ok(schema)
    }

    /// Get column definition by name
    pub fn get_column(&self, name: &str) -> Option<&SchemaColumnDef> {
        self.columns
            .iter()
            .find(|c| c.name.eq_ignore_ascii_case(name))
    }

    /// Get all column names defined in the schema
    pub fn column_names(&self) -> Vec<&str> {
        self.columns.iter().map(|c| c.name.as_str()).collect()
    }

    /// Get owner - prefers direct owner field, falls back to meta.owner
    pub fn get_owner(&self) -> Option<String> {
        if let Some(owner) = &self.owner {
            return Some(owner.clone());
        }
        self.get_meta_string("owner")
    }

    /// Get a metadata value as a string
    pub fn get_meta_string(&self, key: &str) -> Option<String> {
        self.meta.get(key).and_then(|v| match v {
            serde_yaml::Value::String(s) => Some(s.clone()),
            _ => None,
        })
    }

    /// Get a metadata value
    pub fn get_meta(&self, key: &str) -> Option<&serde_yaml::Value> {
        self.meta.get(key)
    }

    /// Extract tests from this schema
    pub fn extract_tests(&self, model_name: &str) -> Vec<SchemaTest> {
        self.columns
            .iter()
            .flat_map(|column| {
                column.tests.iter().filter_map(move |test_def| {
                    parse_test_definition(test_def).map(|test_type| SchemaTest {
                        test_type,
                        column: column.name.clone(),
                        model: crate::model_name::ModelName::new(model_name),
                        config: TestConfig::default(),
                    })
                })
            })
            .collect()
    }
}

/// Column definition in a model's schema YAML
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SchemaColumnDef {
    /// Column name
    pub name: String,

    /// SQL data type (e.g., VARCHAR, INT, TIMESTAMP, DECIMAL(10,2))
    #[serde(rename = "type", alias = "data_type")]
    pub data_type: String,

    /// Column description
    #[serde(default)]
    pub description: Option<String>,

    /// Whether the description was generated by an AI agent.
    /// `Some(true)` = AI-generated, `Some(false)` = human-written, `None` = unknown provenance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description_ai_generated: Option<bool>,

    /// Whether this column is a primary key
    #[serde(default)]
    pub primary_key: bool,

    /// Tests to run on this column
    #[serde(default)]
    pub tests: Vec<TestDefinition>,

    /// Foreign key reference to another model's column
    #[serde(default)]
    pub references: Option<ColumnReference>,

    /// Data classification for governance (pii, sensitive, internal, public)
    #[serde(default)]
    pub classification: Option<DataClassification>,
}

/// Data classification level for governance and compliance
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum DataClassification {
    /// Personally Identifiable Information (highest sensitivity)
    Pii,
    /// Sensitive business data
    Sensitive,
    /// Internal-only data
    Internal,
    /// Public data (lowest sensitivity)
    Public,
}

impl std::fmt::Display for DataClassification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DataClassification::Pii => write!(f, "pii"),
            DataClassification::Sensitive => write!(f, "sensitive"),
            DataClassification::Internal => write!(f, "internal"),
            DataClassification::Public => write!(f, "public"),
        }
    }
}

/// Foreign key reference to another model's column
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ColumnReference {
    /// Referenced model name
    pub model: ModelName,
    /// Referenced column name
    pub column: String,
}

#[cfg(test)]
#[path = "schema_test.rs"]
mod tests;
